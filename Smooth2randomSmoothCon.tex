\documentclass{article}
\usepackage{listings} % for code formatting
\usepackage{hyperref} % for URL

\begin{document}

\title{smooth2random/smoothCon Documentation}
\author{Simon N. Wood}
\maketitle

\section{Convert a smooth to a form suitable for estimating as random effect}
\subsection{Description}
A generic function for converting \texttt{mgcv} smooth objects to forms suitable for estimation as random effects by, for example, \texttt{lme}. Exported mostly for use by other package developers.

\subsection{Usage}
\begin{verbatim}
smooth2random(object, vnames, type=1)
\end{verbatim}

\subsection{Arguments}
\begin{itemize}
    \item \textbf{object:} an \texttt{mgcv} smooth object.
    \item \textbf{vnames:} a vector of names to avoid as dummy variable names in the random effects form.
    \item \textbf{type:} 1 for \texttt{lme}, otherwise \texttt{lmer}.
\end{itemize}

\subsection{Details}
There is a duality between smooths and random effects which means that smooths can be estimated using mixed modelling software. This function converts standard mgcv smooth objects to forms suitable for estimation by lme, for example. A service routine for gamm exported for use by package developers. See examples for creating prediction matrices for new data, corresponding to the random and fixed effect matrices returned when type=2.

\subsection{Value}
A list containing:
\begin{itemize}
    \item \textbf{rand:} a list of random effects, including grouping factors, and a fixed effects matrix.
    \item \textbf{trans.D:} A vector, \texttt{trans.D}, that transforms \texttt{coefs}, in order \([rand1, rand2, \ldots, fix]\) back to original parameterization.
    \item \textbf{trans.U:} A matrix, \texttt{trans.U}, that transforms \texttt{coefs}, in order \([rand1, rand2, \ldots, fix]\) back to original parameterization.
    \item \textbf{Xf:} A matrix for the fixed effects, if any.
\end{itemize}


\subsection{Examples}
\begin{lstlisting}[language=R]
## Simple type 1 'lme' style...
library(mgcv)
x <- runif(30)
sm <- smoothCon(s(x),data.frame(x=x))[[1]]
smooth2random(sm,"")

## Now type 2 'lme4' style...
z <- runif(30)
dat <- data.frame(x=x,z=z)
sm <- smoothCon(t2(x,z),dat)[[1]]
re <- smooth2random(sm,"",2)
str(re)

## For prediction after fitting we might transform parameters back to
## original parameterization using 'rind', 'trans.D' and 'trans.U',
## and call PredictMat(sm,newdata) to get the prediction matrix to
## multiply these transformed parameters by.
## Alternatively we could obtain fixed and random effect Prediction
## matrices corresponding to the results from smooth2random, which
## can be used with the fit parameters without transforming them.
## The following shows how...

s2rPred <- function(sm,re,data) {
## Function to aid prediction from smooths represented as type==2
## random effects. re must be the result of smooth2random(sm,...,type=2).
  X <- PredictMat(sm,data)   ## get prediction matrix for new data
  ## transform to r.e. parameterization
  if (!is.null(re$trans.U)) X <- X%*%re$trans.U
  X <- t(t(X)*re$trans.D)
  ## re-order columns according to random effect re-ordering...
  X[,re$rind] <- X[,re$pen.ind!=0] 
  ## re-order penalization index in same way  
  pen.ind <- re$pen.ind; pen.ind[re$rind] <- pen.ind[pen.ind>0]
  ## start return object...
  r <- list(rand=list(),Xf=X[,which(re$pen.ind==0),drop=FALSE])
  for (i in 1:length(re$rand)) { ## loop over random effect matrices
    r$rand[[i]] <- X[,which(pen.ind==i),drop=FALSE]
    attr(r$rand[[i]],"s.label") <- attr(re$rand[[i]],"s.label")
  }
  names(r$rand) <- names(re$rand)
  r
} ## s2rPred

## use function to obtain prediction random and fixed effect matrices
## for first 10 elements of 'dat'. Then confirm that these match the
## first 10 rows of the original model matrices, as they should...

r <- s2rPred(sm,re,dat[1:10,])
range(r$Xf-re$Xf[1:10,])
range(r$rand[[1]]-re$rand[[1]][1:10,])
smooth2random(sm, "")
\end{lstlisting}


\section{Prediction/Construction wrapper functions for GAM smooth terms}
\subsection{Description}
Wrapper functions for construction of and prediction from smooth terms in a GAM. The purpose of the wrappers is to allow user-transparant re-parameterization of smooth terms, in order to allow identifiability constraints to be absorbed into the parameterization of each term, if required. The routine also handles ‘by’ variables and construction of identifiability constraints automatically, although this behaviour can be over-ridden.

\subsection{Usage}
\begin{verbatim}
smoothCon(object, data, knots=NULL, absorb.cons=FALSE,
          scale.penalty=TRUE, n=nrow(data), dataX=NULL,
          null.space.penalty=FALSE, sparse.cons=0,
          diagonal.penalty=FALSE, apply.by=TRUE, modCon=0)
PredictMat(object, data, n=nrow(data))
\end{verbatim}

\subsection{Arguments}
\begin{description}
\item[object] A smooth specification object or a smooth object.
\item[data] The data frame containing the variables specified in the smooth term.
\item[knots] Optional. Knot points for the basis functions. Defaults to NULL.
\item[absorb.cons] Boolean flag indicating whether identifiability constraints should be absorbed. Defaults to FALSE.
\item[scale.penalty] Boolean flag to scale the penalty matrix or not. Defaults to TRUE.
\item[n] The number of rows in the data frame. Usually inferred as \texttt{nrow(data)}.
\item[dataX] Optional data frame used to create the smooth object.
\item[null.space.penalty] Boolean flag to include null space penalty or not. Defaults to FALSE.
\item[sparse.cons] Integer specifying the sparsity of the constraint matrix. Defaults to 0.
\item[diagonal.penalty] Boolean flag for diagonal penalty matrix. Defaults to FALSE.
\item[apply.by] Boolean flag indicating whether 'by' variables should be applied. Defaults to TRUE.
\item[modCon] Model constraint. Defaults to 0.
\end{description}

\subsection{Details}
The function \texttt{smoothCon} constructs a smooth term based on the provided data and smooth specification object. The function \texttt{PredictMat} generates the prediction matrix based on the smooth object and new data.

The \texttt{s2rPred} function in the example code is a custom function that generates prediction matrices, separating them into random and fixed effect matrices. This is useful for prediction after fitting a model with random effects.

These wrapper functions exist to allow smooths specified using smooth.construct and Predict.matrix method functions to be re-parameterized so that identifiability constraints are no longer required in fitting. This is done in a user transparent manner, but is typically of no importance in use of GAMs. The routine's also handle by variables and will create default identifiability constraints.

If a user defined smooth constructor handles by variables itself, then its returned smooth object should contain an object by.done. If this does not exist then smoothCon will use the default code. Similarly if a user defined Predict.matrix method handles by variables internally then the returned matrix should have a "by.done" attribute.

Default centering constraints, that terms should sum to zero over the covariates, are produced unless the smooth constructor includes a matrix C of constraints. To have no constraints (in which case you had better have a full rank penalty!) the matrix C should have no rows. There is an option to use centering constraint that generate no, or limited infil, if the smoother has a sparse model matrix.

smoothCon returns a list of smooths because factor by variables result in multiple copies of a smooth, each multiplied by the dummy variable associated with one factor level. smoothCon modifies the smooth object labels in the presence of by variables, to ensure that they are unique, it also stores the level of a by variable factor associated with a smooth, for later use by PredictMat.

The parameterization used by gam can be controlled via gam.control.


\subsection{Value}
From smoothCon a list of smooth objects returned by the appropriate smooth.construct method function. If constraints are to be absorbed then the objects will have attributes "qrc" and "nCons". "nCons" is the number of constraints. "qrc" is usually the qr decomposition of the constraint matrix (returned by qr), but if it is a single positive integer it is the index of the coefficient to set to zero, and if it is a negative number then this indicates that the parameters are to sum to zero.

For predictMat a matrix which will map the parameters associated with the smooth to the vector of values of the smooth evaluated at the covariate values given in object.


\subsection{Examples}

\begin{lstlisting}[language=R]
## example of using smoothCon and PredictMat to set up a basis
## to use for regression and make predictions using the result
library(MASS) ## load for mcycle data.
## set up a smoother...
sm <- smoothCon(s(times,k=10),data=mcycle,knots=NULL)[[1]]
## use it to fit a regression spline model...
beta <- coef(lm(mcycle$accel~sm$X-1))
with(mcycle,plot(times,accel)) ## plot data
times <- seq(0,60,length=200)  ## creat prediction times
## Get matrix mapping beta to spline prediction at 'times'
Xp <- PredictMat(sm,data.frame(times=times))
lines(times,Xp%*%beta) ## add smooth to plot

## Same again but using a penalized regression spline of
## rank 30....
sm <- smoothCon(s(times,k=30),data=mcycle,knots=NULL)[[1]]
E <- t(mroot(sm$S[[1]])) ## square root penalty
X <- rbind(sm$X,0.1*E) ## augmented model matrix
y <- c(mcycle$accel,rep(0,nrow(E))) ## augmented data
beta <- coef(lm(y~X-1)) ## fit penalized regression spline
Xp <- PredictMat(sm,data.frame(times=times)) ## prediction matrix
with(mcycle,plot(times,accel)) ## plot data
lines(times,Xp%*%beta) ## overlay smooth
\end{lstlisting}



\section{The outputs after using the functions:}


\end{document}

